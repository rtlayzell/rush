
min(a: orderable) => a;
max(a: orderable) => a;

min(a, b, rest: ...orderable) => min((a < b ? a : b), rest...);
max(a, b, rest: ...orderable) => max((a < b ? b : a), rest...);


take(src: @iterable<T>, count: integer):
	let it = src.iterator();
	while it.next():
		if (--count) <= 0: break;
		yield it.current;

take(src: @iterable<T>, pred: T => bool):
	let it = src.iterator();
	while it.next() && pred(it.current):
		yield it.current;

skip(src: @iterable<T>, count: integer):
	let it = src.iterator();
	var yielding = false;
	while it.next():
		if !yielding && (--count) <= 0: yielding = true;
		if yielding: yield it.current;

skip(src: @iterable<T>, pred: T => bool):
	let it = src.iterator();
	while it.next() && pred(it.current);
	while it.next(): yield it.current;

map(src: @iterable<T>, fn: T => R):
	for item in src:
		yield fn(item);

filter(src: @iterable<T>, fn: T => bool):
	for item in src:
		if fn(item): yield item;

fold(src: @iterable<T>, fn: (T, T) => T):
	let it = src.iterator();
	if it.next():
		var result = it.current;
		while it.next():
			result = fn(result, it.current);
	return result;

fold(src: @iterable<T>, init: T, fn: (T, T) => T):
	for item in src:
		init = fn(init, item);
	return init;


swap(a, b: T&):
	a, b = b, a;

swap(src: indexable<T>, i, j: integer):
	swap(src[i], src[j]);

swap(a, b: T&, pred: (T, T) => bool):
	if pred(a, b):
		swap(a, b);
		return true;
	return false;

swap(src: indexable<T>, i, j: integer, pred: (T, T) => bool):
	if pred(src[i], src[j]):
		swap(src, i, j);
		return true;
	return false;

bubblesort(src: list<T>):
	var swapf = true;
	while swapf:
		swapf = false;
		for i in range(src.length - 1):
			swapf = swap(src, i, i+1, less);



main() => for i in 1..10: writeln(i);

[main][lparen][rparen][=>][for][i][in][1..10][:][writeln][lparen][i][rparen]

package
import
class
interface
type
<identifier>

main():
	let x = math.max(1..10);