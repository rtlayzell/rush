program ::= { toplevel-declaration | expression }


## Declarations

toplevel-declaration ::=
	| [ "export" ] declaration
	| import-declaration
	| module-declaration

declaration ::=
	| constant-declaration
	| variable-declaration
	| function-declaration
	| external-declaration
	| class-declaration
	| struct-declaration
	| concept-declaration
	| interface-declaration

import-declaration = "import" qualified-name
module-declaration = "module" qualified-name
qualified-name ::= identifier [ "." module-name ]

type-alias-declaration ::= "alias" named-type "=" type

constant-declaration-list ::= "let" name-pattern-list [ type-annotation ] intializer
variable-declaration-list ::= "var" name-pattern-list [ type-annotation ] intializer
intializer ::= "=" expression { "," expression }

external-declaration ::= "extern" function-prototype
function-declaration ::= "func" identifier parameter-list ( ":" [ type ] statement-block | "=>" expression )
function-prototype ::= "func" identifier parameter-list [ "=>" type ]

parameter-list ::= "(" parameter-sequence { "," parameter-sequence } ")"
parameter-sequence ::= name-pattern-list ( initializer | type-annotation [ initializer ] )

class-declaration ::= "class"
	| class-definition
	| extension-class-definition

class-definition ::= identifier ":" { standard-class-body-declaration }
class-definition-body ::= { [ access-modifier ] { class-member-declaration-block } }

member-declaration ::=
	| member-constant-declaration
	| member-variable-declaration
	| member-function-declaration

member-constant-declaration ::= "let" identifier-list ( initializer | type-annotation [ initializer ] )
member-variable-declaration ::= "var" identifier-list ( initializer | type-annotation [ initializer ] )

extension-class-definition ::= "@" identifier { extension-class-definition-body }


## Statements

statement ::=
	| expression [ ";" ]
	| declaration
	| statement-block
	| control-statement [ ";" ]
	| compound-statement

compound-statement ::=
	| loop-statement
	| branch-statement

loop-statement ::=
	| for-statement
	| while-statement

branch-statement ::=
	| if-statement
	| switch-statement

control-statement ::=
	| return-statement
	| yield-statement
	| throw-statement
	| pass-statement
	| break-statement
	| continue-statement

statement-block ::= <indent> statement { statement } <dedent>

if-statement ::= "if" condition ":" statement [ else-clause ]
else-clause ::= "else" ( compound-statement | ":" statement )

switch-statement ::= "switch" expression ":" switch-block
switch-block ::= <indent> switch-case { switch-case } <dedent>
switch-case ::= switch-case-pattern { switch-case-pattern } statement
switch-case-pattern ::= "case" pattern ":"

for-statement ::= "for" ( range-expression | pattern "in" expression ) ":" statement

while-statement ::= "while" condition ":" statement

condition ::= expression

throw-statement ::= "throw" expression
yield-statement ::= "yield" expression
return-statement ::= "return" [ expression ]
pass-statement ::= "pass"
break-statement ::= "break"
continue-statement ::= "continue"


## Expressions

expression ::=
	| primary-expression
	| binary-expression
	| unary-expression

primary-expression ::=
	| literal
	| identifier
	| unary-expression
	| member-access-expression
	| "(" expression ")"

binary-expression ::=
	| expression binary-op expression


## Types

type-annotation ::= ":" type

type ::=
	| named-type
	| tuple-type
	| array-type
	| dictionary-type
	| optional-type
	| function-type
	| "(" type ")"
	| "int" | "uint"
	| "long" | "ulong"
	| "short" | "ushort"
	| "float" | "double"
	| "char" | "string"
	| "byte" | "sbyte"
	| "void"
	| "bool"
	| "any"

tuple-type ::= "(" type "," type-list ")"

named-type ::= identifier [ generic-type-clause ] { "." named-type }
generic-type-clause ::= "<" type-list ">"

array-type ::= type array-type-clause
array-type-clause ::= "[" [ integer-literal ] { "," [ integer-literal ] } "]"

dictionary-type ::= type dictionary-type-clause
dictionary-type-clause ::= "[" type "]"

optional-type ::= type "?"

function-type ::= "(" [ type-list ] ")" "=>" type

type-list ::= type { "," type }


## Misc.

name-pattern-list ::= name-pattern { "," name-pattern }
name-pattern ::=
	| destructure-pattern
	| identifier

destructure-pattern ::= "{" name-pattern-sequence "}"

string-literal ::= '"' string-segment { string-substitution | string-segment } '"'
string-segment ::= string-escape-sequence | { string-char }
string-substitution ::= "$" ( "{" expression "}" | identifier )

string-literal ::= '"' string-segment { string-substitution string-segment } '"'
string-segment ::= { string-escape-sequence | string-char }
string-substitution ::= "$" ( "{" expression "}" | identifier )

string-char ::= /[^\\$"]/
string-escape-sequence ::= /\\['"\\bfnrtv$]/

## Terminals

unary-op ::= "+" | "-" ...
binary-op ::= "+" | "-" | "*" | "/" | "%" ...


letter = /[a-z]/i

digit = /[0-9]/
hex-digit = /[a-f0-9]/i
oct-digit = /[0-7]/
bin-digit = /0|1/
non-zero-digit = /[1-9]/

