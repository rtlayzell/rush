import std.collections

export func each<T>(src: @iterable<T>, fn: T -> void)
	for item in src
		fn(item)

export func any<T>(src: @iterable<T>)
	return src.iterator().next()

export func any<T>(src: @iterable<T>, pred: T -> bool)
	for item in src
		if pred(item) return true
	return false

export func all<T>(src: @iterable<T>, pred: T -> bool)
	for item in src
		if !pred(item) return false
	return true

export func take<T>(count: var int, src: @iterable<T>)
	let it = src.iterator()
	while count-- > 0 && it.next()
		yield it.value

export func take<T>(src: @iterable<T>, pred: T -> bool)
	let it = src.iterator()
	while it.next() && pred(it.value)
		yield it.value

export func skip<T>(count: var int, src: @iterable<T>)
	let it = src.iterator()
	while count-- > 0 && it.next()
	while it.next() yield it.value

export func skip<T>(src: @iterable<T>, pred: T -> bool)
	let it = src.iterator()
	while it.next() && pred(it.value)
	while it.next() yield it.value

export func map<T, R>(src: @iterable<T>, fn: T -> R)
	for item in src
		yield fn(item)

export func filter<T>(src: @iterable<T>, fn: T -> bool)
	for item in src
		if fn(item) yield item

export func reduce<T>(src: @iterable<T>, fn: (T, T) -> T)
	let it = src.iterator()
	if it.next()
		var result = it.value
		while it.next()
			result = fn(result, it.value)
		return result

export func reduce<T, R>(src: @iterable<T>, init: var R, fn: (R, T) -> R)
	let it = src.iterator()
	while it.next()
		init = fn(init, it.value)
	return init

## interweaves the inner value between the collection of items.
## think of it as a generic string.join
export func lace<T>(src: @iterable<T>, inner: T, fn: (T, T) -> T)
	let it = src.iterator()
	while it.next()


export func first<T>(src: @iterable<T>)
   let it = src.iterator()
   if it.next() == false
      throw new sequence_error("The collection is empty.")

   return it.value


export func first<T>(src: @iterable<T>, pred: T -> bool)
	let it = src.iterator()
	if it.next() == false
		throw new sequence_error("The collection is empty.")

	if pred(it.value)
		return it.value

	while it.next()
		if pred(it.value)
			return it.value

	throw new sequence_error("Item not found.")


export func last<T>(src: @indexable<T>)
   if src.length == 0
      throw new sequence_error("The collection is empty.")

   return src[src.length - 1]


export func last<T>(src: @iterable<T>)
   let it = src.iterator()
   if it.next() == false
      throw new sequence_error("The collection is empty.")

   while it.next()
   return it.value